<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Robo Demo - Physics Simulation with Rapier</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #eee;
            overflow: hidden;
        }
        #container { display: flex; height: 100vh; }
        #canvas-container { flex: 1; position: relative; }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.5rem;
            color: #e94560;
        }
        #sidebar {
            width: 360px;
            background: #16213e;
            padding: 20px;
            overflow-y: auto;
            border-left: 1px solid #0f3460;
        }
        h1 { font-size: 1.4rem; margin-bottom: 20px; color: #e94560; }
        h2 {
            font-size: 1rem;
            margin: 20px 0 10px;
            color: #0f4c75;
            border-bottom: 1px solid #0f3460;
            padding-bottom: 5px;
        }
        .joint-control { margin-bottom: 15px; }
        .joint-control label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 0.9rem;
        }
        .joint-control input[type="range"] { width: 100%; accent-color: #e94560; }
        .joint-value { color: #e94560; font-family: monospace; }
        .btn {
            background: #e94560;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9rem;
            margin: 5px 5px 5px 0;
            transition: background 0.2s;
        }
        .btn:hover { background: #ff6b6b; }
        .btn-secondary { background: #0f4c75; }
        .btn-secondary:hover { background: #1a6ca8; }
        .btn-magnet {
            background: #27ae60;
            width: 100%;
            padding: 15px;
            font-size: 1rem;
        }
        .btn-magnet.active {
            background: #e94560;
            animation: magnetPulse 1s infinite;
        }
        @keyframes magnetPulse {
            0%, 100% { box-shadow: 0 0 5px #e94560; }
            50% { box-shadow: 0 0 20px #e94560; }
        }
        .physics-info {
            background: #0d1b2a;
            padding: 10px;
            border-radius: 5px;
            font-size: 0.8rem;
            margin-top: 10px;
        }
        .physics-info div {
            display: flex;
            justify-content: space-between;
            margin: 3px 0;
        }
        #end-effector-pos { font-family: monospace; color: #2ecc71; }
        #magnet-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #555;
            margin-left: 10px;
            transition: all 0.3s;
        }
        #magnet-indicator.active {
            background: #e94560;
            box-shadow: 0 0 10px #e94560;
        }
        .object-list { margin-top: 10px; }
        .object-item {
            background: #0d1b2a;
            padding: 8px 12px;
            border-radius: 4px;
            margin-bottom: 5px;
            font-size: 0.85rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .object-item.attached { border-left: 3px solid #e94560; }
        .hint { font-size: 0.75rem; color: #888; margin-top: 5px; }
    </style>
</head>
<body>
    <div id="container">
        <div id="canvas-container">
            <div id="loading">Loading Rapier Physics Engine...</div>
            <canvas id="canvas"></canvas>
        </div>
        <div id="sidebar">
            <h1>ðŸ¤– Robo Demo <span id="magnet-indicator"></span></h1>
            <p class="hint">Physics powered by Rapier</p>

            <div id="controls-tab">
                <h2>Joint Controls</h2>
                <div id="joint-controls"></div>

                <h2>Magnet</h2>
                <button class="btn btn-magnet" id="magnet-btn" onclick="toggleMagnet()">
                    ðŸ§² Magnet OFF
                </button>
                <p class="hint">Attracts metal objects within range when ON</p>

                <h2>Actions</h2>
                <button class="btn" onclick="resetArm()">Reset Position</button>
                <button class="btn btn-secondary" onclick="resetObjects()">Reset Objects</button>

                <h2>End Effector</h2>
                <div class="physics-info">
                    <div><span>Position:</span><span id="end-effector-pos">-</span></div>
                    <div><span>Magnet:</span><span id="magnet-status">OFF</span></div>
                </div>

                <h2>Scene Objects</h2>
                <p class="hint">Objects have physics - push them with the arm!</p>
                <div id="object-list" class="object-list"></div>

                <h2>MCP</h2>
                <div class="physics-info">
                    <div><span>Status:</span><span id="mcp-connected">Disconnected</span></div>
                </div>
            </div>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
            "@dimforge/rapier3d-compat": "https://cdn.jsdelivr.net/npm/@dimforge/rapier3d-compat@0.14.0/+esm"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import RAPIER from '@dimforge/rapier3d-compat';

        // API Base URL
        const API_BASE = window.location.origin;

        // Default object positions (never modified - used for reset)
        const DEFAULT_OBJECT_POSITIONS = {
            'cube1': [0.4, 0.025, 0.3],
            'cube2': [-0.3, 0.025, 0.4],
            'cylinder1': [0.25, 0.03, -0.35]
        };

        // Configuration
        const CONFIG = {
            arm: {
                baseHeight: 0.1,
                segments: [
                    { length: 0.25, radius: 0.05, axis: 'y', range: [-180, 180] },  // Base rotation
                    { length: 0.35, radius: 0.045, axis: 'z', range: [-90, 90] },   // Shoulder
                    { length: 0.30, radius: 0.04, axis: 'z', range: [-135, 135] },  // Elbow
                    { length: 0.15, radius: 0.035, axis: 'x', range: [-180, 180] }, // Wrist roll
                    { length: 0.12, radius: 0.03, axis: 'z', range: [-90, 90] },    // Wrist pitch
                    { length: 0.08, radius: 0.025, axis: 'x', range: [-180, 180] }  // Wrist rotation
                ],
                jointSpeed: 2.0, // radians per second
                magnetRadius: 0.12,
                magnetStrength: 15.0
            },
            objects: [
                { id: 'cube1', type: 'cube', position: [0.4, 0.025, 0.3], size: 0.05, color: 0xc0c0c0 },
                { id: 'cube2', type: 'cube', position: [-0.3, 0.025, 0.4], size: 0.04, color: 0xa0a0a0 },
                { id: 'cylinder1', type: 'cylinder', position: [0.25, 0.03, -0.35], size: 0.03, color: 0xd0d0d0 }
            ]
        };

        // State
        let world, eventQueue;
        let jointTargets = [0, 0, 0, 0, 0, 0];
        let jointAngles = [0, 0, 0, 0, 0, 0];
        let magnetOn = false;
        let attachedObject = null;
        let magnetConstraint = null;

        // Motion completion tracking
        let lastMotionComplete = true;
        const MOTION_TOLERANCE = 1.0; // degrees

        function checkMotionComplete() {
            for (let i = 0; i < 6; i++) {
                if (Math.abs(jointTargets[i] - jointAngles[i]) > MOTION_TOLERANCE) {
                    return false;
                }
            }
            return true;
        }

        function reportMotionStatus() {
            const complete = checkMotionComplete();
            if (complete !== lastMotionComplete) {
                lastMotionComplete = complete;
                fetch(`${API_BASE}/api/motion-status`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ complete, jointAngles: [...jointAngles] })
                }).catch(() => {});
            }
        }

        function reportAttachmentStatus(objectId, attached) {
            fetch(`${API_BASE}/api/attachment-status`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ objectId, attached })
            }).catch(() => {});
        }

        // ====================================================================
        // CLIENT-SIDE IK SOLVER & TASK EXECUTION
        // ====================================================================

        const ARM_IK = {
            baseHeight: 0.1,
            L1: 0.35,
            L2: 0.30,
            L3: 0.35,
            reachRadius: 0.80,
            maxHeight: 0.95,
            minHeight: 0.05
        };

        const IK_JOINT_LIMITS = [
            [-180, 180], [-90, 90], [-135, 135],
            [-180, 180], [-90, 90], [-180, 180]
        ];

        function solveIK(targetPos) {
            const { baseHeight, L1, L2, L3 } = ARM_IK;
            const theta0 = Math.atan2(targetPos.x, targetPos.z);
            const r = Math.sqrt(targetPos.x ** 2 + targetPos.z ** 2);
            const h = targetPos.y - baseHeight - L3;
            const d = Math.sqrt(r ** 2 + h ** 2);
            if (d > L1 + L2 - 0.01 || d < Math.abs(L1 - L2) + 0.01) return null;
            const cos_theta2 = (d ** 2 - L1 ** 2 - L2 ** 2) / (2 * L1 * L2);
            const theta2 = -Math.acos(Math.max(-1, Math.min(1, cos_theta2)));
            const alpha = Math.atan2(h, r);
            const cos_beta = (L1 ** 2 + d ** 2 - L2 ** 2) / (2 * L1 * d);
            const beta = Math.acos(Math.max(-1, Math.min(1, cos_beta)));
            const theta1 = alpha + beta - Math.PI / 2;
            const theta3 = 0;
            const theta4 = -(theta1 + theta2);
            const theta5 = -theta0;
            return [theta0, theta1, theta2, theta3, theta4, theta5].map((rad, i) => {
                const deg = rad * 180 / Math.PI;
                return Math.max(IK_JOINT_LIMITS[i][0], Math.min(IK_JOINT_LIMITS[i][1], deg));
            });
        }

        function localSleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function waitForLocalMotionComplete(timeoutMs = 10000) {
            return new Promise((resolve) => {
                const startTime = Date.now();
                function check() {
                    if (checkMotionComplete()) {
                        resolve(true);
                    } else if (Date.now() - startTime > timeoutMs) {
                        resolve(false);
                    } else {
                        requestAnimationFrame(check);
                    }
                }
                check();
            });
        }

        async function localMoveTo(position) {
            const angles = solveIK(position);
            if (!angles) throw new Error('OUT_OF_REACH');
            for (let i = 0; i < 6; i++) {
                jointTargets[i] = angles[i];
                updateSliderUI(i, angles[i]);
            }
            await waitForLocalMotionComplete();
            await localSleep(100);
        }

        async function localSetMagnet(enabled) {
            magnetOn = enabled;
            updateMagnetUI();
            await localSleep(200);
        }

        function getObjectPosition(objectId) {
            const entry = objectBodies.get(objectId);
            if (!entry) return null;
            const pos = entry.body.translation();
            return { x: pos.x, y: pos.y, z: pos.z };
        }

        function waitForLocalAttachment(objectId, timeoutMs = 3000) {
            return new Promise((resolve) => {
                const startTime = Date.now();
                function check() {
                    const entry = objectBodies.get(objectId);
                    if (entry && entry.mesh.userData.attached) {
                        resolve(true);
                    } else if (Date.now() - startTime > timeoutMs) {
                        resolve(false);
                    } else {
                        requestAnimationFrame(check);
                    }
                }
                check();
            });
        }

        // Task execution functions (run entirely in the browser)
        async function localExecutePickObject(objectId) {
            const startTime = Date.now();
            const pos = getObjectPosition(objectId);
            if (!pos) {
                return { success: false, message: `Object '${objectId}' not found`, error_code: 'OBJECT_NOT_FOUND', duration_ms: Date.now() - startTime };
            }
            if (magnetOn && attachedObject) {
                return { success: false, message: `Already holding object '${attachedObject}'`, error_code: 'ALREADY_HOLDING_OBJECT', duration_ms: Date.now() - startTime };
            }
            try {
                const abovePos = { x: pos.x, y: 0.30, z: pos.z };
                const pickPos = { x: pos.x, y: pos.y + 0.12, z: pos.z };
                const liftPos = { x: pos.x, y: 0.35, z: pos.z };
                await localMoveTo(abovePos);
                await localMoveTo(pickPos);
                await localSetMagnet(true);
                await waitForLocalAttachment(objectId, 2000);
                await localSleep(300);
                await localMoveTo(liftPos);
                return { success: true, message: `Successfully picked up '${objectId}'`, error_code: null, duration_ms: Date.now() - startTime };
            } catch (error) {
                return { success: false, message: error.message, error_code: error.message, duration_ms: Date.now() - startTime };
            }
        }

        async function localExecuteCarryTo(x, y, z) {
            const startTime = Date.now();
            if (!magnetOn || !attachedObject) {
                return { success: false, message: 'Not holding any object', error_code: 'NO_OBJECT_HELD', duration_ms: Date.now() - startTime };
            }
            try {
                await localMoveTo({ x, y, z });
                return { success: true, message: `Carried object to (${x.toFixed(2)}, ${y.toFixed(2)}, ${z.toFixed(2)})`, error_code: null, duration_ms: Date.now() - startTime };
            } catch (error) {
                return { success: false, message: error.message, error_code: error.message, duration_ms: Date.now() - startTime };
            }
        }

        async function localExecutePlaceObject(params = {}) {
            const startTime = Date.now();
            if (!magnetOn || !attachedObject) {
                return { success: false, message: 'Not holding any object', error_code: 'NO_OBJECT_HELD', duration_ms: Date.now() - startTime };
            }
            const objectId = attachedObject;
            try {
                if (params.x !== undefined && params.y !== undefined && params.z !== undefined) {
                    await localMoveTo({ x: params.x, y: params.y, z: params.z });
                }
                await localSetMagnet(false);
                await localSleep(500);
                return { success: true, message: `Placed object '${objectId}'`, error_code: null, duration_ms: Date.now() - startTime };
            } catch (error) {
                return { success: false, message: error.message, error_code: error.message, duration_ms: Date.now() - startTime };
            }
        }

        async function localExecuteDance(durationSeconds) {
            const startTime = Date.now();
            const danceFrames = [
                [0, 0, 0, 0, 0, 0],
                [45, 20, -30, 0, 10, 90],
                [-45, 20, -30, 0, 10, -90],
                [0, 45, -90, 45, 30, 0],
                [0, -10, 30, 0, -20, 180],
                [90, 30, -60, 90, 0, 45],
                [-90, 30, -60, -90, 0, -45],
                [0, 0, 0, 0, 0, 0],
            ];
            const frameTime = (durationSeconds * 1000) / danceFrames.length;
            for (const frame of danceFrames) {
                for (let i = 0; i < 6; i++) {
                    jointTargets[i] = frame[i];
                    updateSliderUI(i, frame[i]);
                }
                await localSleep(frameTime);
                await waitForLocalMotionComplete(5000);
            }
            return { success: true, message: `Dance completed (${durationSeconds}s)`, error_code: null, duration_ms: Date.now() - startTime };
        }

        async function localExecuteResetToBase() {
            const startTime = Date.now();
            if (magnetOn) {
                await localSetMagnet(false);
                await localSleep(300);
            }
            for (let i = 0; i < 6; i++) {
                jointTargets[i] = 0;
                updateSliderUI(i, 0);
            }
            await waitForLocalMotionComplete();
            return { success: true, message: 'Arm reset to home position', error_code: null, duration_ms: Date.now() - startTime };
        }

        async function localTakeScreenshot(width, height) {
            try {
                const container = document.getElementById('canvas-container');
                const origWidth = container.clientWidth;
                const origHeight = container.clientHeight;
                const w = width || 800;
                const h = height || 600;
                renderer.setSize(w, h);
                camera.aspect = w / h;
                camera.updateProjectionMatrix();
                renderer.render(scene, camera);
                const imageData = renderer.domElement.toDataURL('image/png').split(',')[1];
                renderer.setSize(origWidth, origHeight);
                camera.aspect = origWidth / origHeight;
                camera.updateProjectionMatrix();
                return { imageData };
            } catch (error) {
                return { success: false, error: error.message };
            }
        }

        // Command queue processing
        let processingCommand = false;
        let lastProcessedCommandId = null;

        async function processCommand(command) {
            if (processingCommand) return;
            if (command.id === lastProcessedCommandId) return;
            processingCommand = true;
            console.log(`[MCP] Executing: ${command.tool}`, command.args);

            let result;
            try {
                switch (command.tool) {
                    case 'pick_object':
                        result = await localExecutePickObject(command.args.object_id);
                        break;
                    case 'carry_to':
                        result = await localExecuteCarryTo(command.args.x, command.args.y, command.args.z);
                        break;
                    case 'place_object':
                        result = await localExecutePlaceObject(command.args);
                        break;
                    case 'dance':
                        result = await localExecuteDance(command.args.duration_seconds || 5);
                        break;
                    case 'reset_to_base':
                        result = await localExecuteResetToBase();
                        break;
                    case 'take_screenshot':
                        result = await localTakeScreenshot(command.args.width, command.args.height);
                        break;
                    default:
                        result = { success: false, error: `Unknown command: ${command.tool}` };
                }
            } catch (error) {
                result = { success: false, error: error.message };
            }

            console.log(`[MCP] Result:`, result.success !== undefined ? result.success : 'screenshot');

            // Post result back to server
            try {
                await fetch(`${API_BASE}/api/command-result`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        commandId: command.id,
                        ...result,
                        jointTargets: [...jointTargets],
                        magnetOn,
                        attachedObject
                    })
                });
            } catch (e) {
                console.error('[MCP] Failed to post command result:', e);
            }

            lastProcessedCommandId = command.id;
            processingCommand = false;
        }

        // Three.js objects
        let scene, camera, renderer, controls;
        const armSegments = [];
        const jointGroups = [];
        const objectMeshes = new Map();
        const objectBodies = new Map();
        let magnetBall = null;

        // Rapier bodies
        let armBodies = [];
        let armJoints = [];

        // Load persisted state from server
        async function loadPersistedState() {
            try {
                const res = await fetch(`${API_BASE}/api/state`);
                const state = await res.json();

                if (state.jointTargets) {
                    jointTargets = [...state.jointTargets];
                    jointAngles = [...state.jointTargets]; // Start at target position
                }
                if (state.magnetOn !== undefined) {
                    magnetOn = state.magnetOn;
                }
                if (state.objects) {
                    // Update CONFIG with persisted positions
                    state.objects.forEach(obj => {
                        const configObj = CONFIG.objects.find(c => c.id === obj.id);
                        if (configObj && obj.position) {
                            configObj.position = [obj.position.x, obj.position.y, obj.position.z];
                        }
                    });
                }
            } catch (e) {
                console.log('Could not load persisted state');
            }
        }

        // Save object positions to server periodically
        function saveObjectPositions() {
            const objects = [];
            objectBodies.forEach(({ body, config }, id) => {
                const pos = body.translation();
                objects.push({
                    id,
                    position: { x: pos.x, y: pos.y, z: pos.z }
                });
            });

            fetch(`${API_BASE}/api/objects`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ objects })
            }).catch(() => {});
        }

        // Initialize
        async function init() {
            // Load persisted state first
            await loadPersistedState();

            // Initialize Rapier
            await RAPIER.init();
            document.getElementById('loading').style.display = 'none';

            // Create physics world
            const gravity = { x: 0.0, y: -9.81, z: 0.0 };
            world = new RAPIER.World(gravity);
            eventQueue = new RAPIER.EventQueue(true);

            // Setup Three.js
            setupThreeJS();

            // Create scene
            createGround();
            createArm();
            createObjects();
            createJointControls();
            setupMouseDragging();

            // Connect to server (polling for Vercel compatibility)
            startPolling();

            // Start animation loop
            animate();
        }

        function setupThreeJS() {
            const canvas = document.getElementById('canvas');
            const container = document.getElementById('canvas-container');

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xd0d8e0);

            camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(1.5, 1.2, 1.5);

            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.target.set(0, 0.4, 0);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            const fillLight = new THREE.DirectionalLight(0xffffff, 0.4);
            fillLight.position.set(-5, 5, -5);
            scene.add(fillLight);

            // Grid
            const gridHelper = new THREE.GridHelper(4, 20, 0x607080, 0x8090a0);
            scene.add(gridHelper);

            window.addEventListener('resize', () => {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            });
        }

        function createGround() {
            // Visual ground
            const groundGeometry = new THREE.PlaneGeometry(4, 4);
            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0xa8b5c4,
                roughness: 0.8,
                metalness: 0.1
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Physics ground (static collider)
            const groundColliderDesc = RAPIER.ColliderDesc.cuboid(2, 0.01, 2)
                .setTranslation(0, -0.01, 0);
            world.createCollider(groundColliderDesc);
        }

        function createArm() {
            const { baseHeight, segments } = CONFIG.arm;

            // Base (fixed)
            const baseGeometry = new THREE.CylinderGeometry(0.12, 0.15, baseHeight, 32);
            const baseMaterial = new THREE.MeshStandardMaterial({
                color: 0x0f4c75,
                roughness: 0.3,
                metalness: 0.7
            });
            const baseMesh = new THREE.Mesh(baseGeometry, baseMaterial);
            baseMesh.position.y = baseHeight / 2;
            baseMesh.castShadow = true;
            scene.add(baseMesh);

            // Base physics body (fixed)
            const baseBodyDesc = RAPIER.RigidBodyDesc.fixed()
                .setTranslation(0, baseHeight / 2, 0);
            const baseBody = world.createRigidBody(baseBodyDesc);
            const baseColliderDesc = RAPIER.ColliderDesc.cylinder(baseHeight / 2, 0.12);
            world.createCollider(baseColliderDesc, baseBody);
            armBodies.push(baseBody);

            // Create arm segments with revolute joints
            let parentBody = baseBody;
            let yOffset = baseHeight;

            for (let i = 0; i < segments.length; i++) {
                const seg = segments[i];
                const segGroup = new THREE.Group();
                jointGroups.push(segGroup);

                // Joint sphere
                const jointGeometry = new THREE.SphereGeometry(seg.radius * 1.2, 16, 16);
                const jointMaterial = new THREE.MeshStandardMaterial({
                    color: 0xe94560,
                    roughness: 0.3,
                    metalness: 0.6
                });
                const jointMesh = new THREE.Mesh(jointGeometry, jointMaterial);
                jointMesh.castShadow = true;
                segGroup.add(jointMesh);

                // Segment cylinder
                const segGeometry = new THREE.CylinderGeometry(seg.radius, seg.radius * 0.9, seg.length, 16);
                const segMaterial = new THREE.MeshStandardMaterial({
                    color: i % 2 === 0 ? 0x1e88e5 : 0x0f4c75,
                    roughness: 0.4,
                    metalness: 0.5
                });
                const segMesh = new THREE.Mesh(segGeometry, segMaterial);
                segMesh.position.y = seg.length / 2;
                segMesh.castShadow = true;
                segGroup.add(segMesh);

                segGroup.position.y = yOffset;
                scene.add(segGroup);
                armSegments.push(segGroup);

                // Physics body for this segment (kinematic for motor control)
                const bodyDesc = RAPIER.RigidBodyDesc.kinematicPositionBased()
                    .setTranslation(0, yOffset + seg.length / 2, 0);
                const body = world.createRigidBody(bodyDesc);

                // Collider for the segment
                const colliderDesc = RAPIER.ColliderDesc.cylinder(seg.length / 2, seg.radius)
                    .setDensity(1.0);
                world.createCollider(colliderDesc, body);

                armBodies.push(body);
                yOffset += seg.length;
            }

            // Add magnetic ball at end
            createMagnetBall(yOffset);
        }

        function createMagnetBall(yOffset) {
            const ballGeometry = new THREE.SphereGeometry(0.04, 32, 32);
            const ballMaterial = new THREE.MeshStandardMaterial({
                color: 0x444444,
                roughness: 0.2,
                metalness: 0.9
            });
            magnetBall = new THREE.Mesh(ballGeometry, ballMaterial);
            magnetBall.position.y = yOffset;
            magnetBall.castShadow = true;
            scene.add(magnetBall);

            // Glow ring
            const ringGeometry = new THREE.TorusGeometry(0.05, 0.006, 8, 32);
            const ringMaterial = new THREE.MeshBasicMaterial({ color: 0x555555 });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.rotation.x = Math.PI / 2;
            magnetBall.add(ring);
            magnetBall.ring = ring;
        }

        function createObjects() {
            CONFIG.objects.forEach(objConfig => {
                let geometry, colliderDesc;
                const halfSize = objConfig.size / 2;

                if (objConfig.type === 'cube') {
                    geometry = new THREE.BoxGeometry(objConfig.size, objConfig.size, objConfig.size);
                    colliderDesc = RAPIER.ColliderDesc.cuboid(halfSize, halfSize, halfSize);
                } else if (objConfig.type === 'cylinder') {
                    geometry = new THREE.CylinderGeometry(objConfig.size, objConfig.size, objConfig.size * 1.5, 16);
                    colliderDesc = RAPIER.ColliderDesc.cylinder(objConfig.size * 0.75, objConfig.size);
                } else {
                    geometry = new THREE.SphereGeometry(objConfig.size, 16, 16);
                    colliderDesc = RAPIER.ColliderDesc.ball(objConfig.size);
                }

                const material = new THREE.MeshStandardMaterial({
                    color: objConfig.color,
                    roughness: 0.3,
                    metalness: 0.8
                });

                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(...objConfig.position);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                scene.add(mesh);
                objectMeshes.set(objConfig.id, mesh);

                // Physics body (dynamic)
                const bodyDesc = RAPIER.RigidBodyDesc.dynamic()
                    .setTranslation(...objConfig.position)
                    .setLinearDamping(0.5)
                    .setAngularDamping(0.5);
                const body = world.createRigidBody(bodyDesc);

                colliderDesc.setDensity(2.0)
                    .setFriction(0.7)
                    .setRestitution(0.3);
                world.createCollider(colliderDesc, body);

                objectBodies.set(objConfig.id, { body, config: objConfig, mesh });
            });
        }

        // Mouse dragging for objects (User A can move objects)
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let isDragging = false;
        let draggedObject = null;
        let dragPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);

        function setupMouseDragging() {
            const canvas = renderer.domElement;

            canvas.addEventListener('mousedown', (event) => {
                if (event.button !== 0) return; // Left click only

                const rect = canvas.getBoundingClientRect();
                mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);
                const meshes = Array.from(objectMeshes.values());
                const intersects = raycaster.intersectObjects(meshes);

                if (intersects.length > 0) {
                    const mesh = intersects[0].object;
                    const objData = [...objectBodies.values()].find(d => d.mesh === mesh);

                    // Don't drag if attached to magnet
                    if (objData && !mesh.userData.attached) {
                        isDragging = true;
                        draggedObject = objData;
                        controls.enabled = false;
                        dragPlane.constant = -mesh.position.y;
                    }
                }
            });

            canvas.addEventListener('mousemove', (event) => {
                if (!isDragging || !draggedObject) return;

                const rect = canvas.getBoundingClientRect();
                mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);
                const intersectPoint = new THREE.Vector3();
                raycaster.ray.intersectPlane(dragPlane, intersectPoint);

                if (intersectPoint) {
                    // Move physics body to new position
                    draggedObject.body.setTranslation({
                        x: intersectPoint.x,
                        y: draggedObject.mesh.position.y,
                        z: intersectPoint.z
                    }, true);
                    draggedObject.body.setLinvel({ x: 0, y: 0, z: 0 }, true);
                    draggedObject.body.setAngvel({ x: 0, y: 0, z: 0 }, true);
                }
            });

            canvas.addEventListener('mouseup', () => {
                isDragging = false;
                draggedObject = null;
                controls.enabled = true;
            });

            canvas.addEventListener('mouseleave', () => {
                isDragging = false;
                draggedObject = null;
                controls.enabled = true;
            });
        }

        function updateArmKinematics() {
            const { segments } = CONFIG.arm;
            let position = new THREE.Vector3(0, CONFIG.arm.baseHeight, 0);
            let rotation = new THREE.Quaternion();

            for (let i = 0; i < segments.length; i++) {
                const seg = segments[i];
                const angle = jointAngles[i] * Math.PI / 180;

                // Apply rotation for this joint
                const jointQuat = new THREE.Quaternion();
                if (seg.axis === 'x') jointQuat.setFromAxisAngle(new THREE.Vector3(1, 0, 0), angle);
                else if (seg.axis === 'y') jointQuat.setFromAxisAngle(new THREE.Vector3(0, 1, 0), angle);
                else jointQuat.setFromAxisAngle(new THREE.Vector3(0, 0, 1), angle);

                rotation.multiply(jointQuat);

                // Update visual
                if (jointGroups[i]) {
                    jointGroups[i].position.copy(position);
                    jointGroups[i].quaternion.copy(rotation);
                }

                // Update physics body - clamp segment center above floor
                if (armBodies[i + 1]) {
                    const segCenter = position.clone();
                    const segOffset = new THREE.Vector3(0, seg.length / 2, 0);
                    segOffset.applyQuaternion(rotation);
                    segCenter.add(segOffset);

                    // Clamp segment center above floor (min height = segment radius)
                    segCenter.y = Math.max(segCenter.y, seg.radius + 0.01);

                    armBodies[i + 1].setNextKinematicTranslation({
                        x: segCenter.x,
                        y: segCenter.y,
                        z: segCenter.z
                    });
                    armBodies[i + 1].setNextKinematicRotation({
                        x: rotation.x,
                        y: rotation.y,
                        z: rotation.z,
                        w: rotation.w
                    });
                }

                // Move position to end of this segment
                const segEnd = new THREE.Vector3(0, seg.length, 0);
                segEnd.applyQuaternion(rotation);
                position.add(segEnd);

                // Clamp position above floor for next segment
                position.y = Math.max(position.y, 0.02);
            }

            // Update magnet ball position (clamp above floor)
            if (magnetBall) {
                position.y = Math.max(position.y, 0.05); // Don't go below floor
                magnetBall.position.copy(position);
                magnetBall.quaternion.copy(rotation);

                // Visual feedback for magnet state
                magnetBall.material.color.setHex(magnetOn ? 0xe94560 : 0x444444);
                magnetBall.ring.material.color.setHex(magnetOn ? 0xff6b6b : 0x555555);
                if (magnetOn) {
                    magnetBall.material.emissive = new THREE.Color(0x330011);
                } else {
                    magnetBall.material.emissive = new THREE.Color(0x000000);
                }
            }

            return position;
        }

        function updateMagneticForce() {
            if (!magnetBall) return;

            const magnetPos = magnetBall.position;
            const { magnetRadius, magnetStrength } = CONFIG.arm;

            objectBodies.forEach(({ body, config, mesh }, id) => {
                const bodyPos = body.translation();

                // SAFETY: Reset objects that have gone out of bounds
                if (Math.abs(bodyPos.x) > 5 || Math.abs(bodyPos.y) > 5 || Math.abs(bodyPos.z) > 5) {
                    console.log(`Resetting ${id} - out of bounds`);
                    const origPos = DEFAULT_OBJECT_POSITIONS[id] || [0, 0.1, 0];
                    body.setTranslation({ x: origPos[0], y: origPos[1], z: origPos[2] }, true);
                    body.setLinvel({ x: 0, y: 0, z: 0 }, true);
                    body.setAngvel({ x: 0, y: 0, z: 0 }, true);
                    mesh.userData.attached = false;
                    return;
                }

                const dx = magnetPos.x - bodyPos.x;
                const dy = magnetPos.y - bodyPos.y;
                const dz = magnetPos.z - bodyPos.z;
                const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);

                if (magnetOn) {
                    if (mesh.userData.attached) {
                        // Already attached - keep snapped BELOW magnet position
                        const snapY = Math.max(magnetPos.y - 0.06, config.size * 0.5 + 0.01);
                        body.setTranslation({
                            x: magnetPos.x,
                            y: snapY,
                            z: magnetPos.z
                        }, true);
                        body.setLinvel({ x: 0, y: 0, z: 0 }, true);
                        body.setAngvel({ x: 0, y: 0, z: 0 }, true);
                    } else if (dist < magnetRadius) {
                        // Apply attractive force toward magnet (capped for stability)
                        const forceMag = Math.min(magnetStrength / (dist * dist + 0.1), 50);
                        const force = {
                            x: (dx / dist) * forceMag,
                            y: (dy / dist) * forceMag,
                            z: (dz / dist) * forceMag
                        };
                        body.applyImpulse(force, true);

                        // If very close, snap and attach
                        if (dist < 0.08) {
                            mesh.userData.attached = true;
                            attachedObject = id;
                            // Immediately set position to prevent physics instability
                            const snapY = Math.max(magnetPos.y - 0.06, config.size * 0.5 + 0.01);
                            body.setTranslation({ x: magnetPos.x, y: snapY, z: magnetPos.z }, true);
                            body.setLinvel({ x: 0, y: 0, z: 0 }, true);
                            body.setAngvel({ x: 0, y: 0, z: 0 }, true);
                            // Report attachment to server
                            reportAttachmentStatus(id, true);
                        }
                    }
                } else if (mesh.userData.attached) {
                    // Magnet turned off - release object, let it fall straight down
                    mesh.userData.attached = false;
                    const releasedId = attachedObject;
                    attachedObject = null;
                    // Zero out velocity and let gravity take over
                    body.setLinvel({ x: 0, y: 0, z: 0 }, true);
                    body.setAngvel({ x: 0, y: 0, z: 0 }, true);
                    body.wakeUp();
                    // Report detachment to server
                    reportAttachmentStatus(releasedId || id, false);
                }
            });
        }

        function syncPhysicsToVisuals() {
            objectBodies.forEach(({ body, mesh }) => {
                const pos = body.translation();
                const rot = body.rotation();
                mesh.position.set(pos.x, pos.y, pos.z);
                mesh.quaternion.set(rot.x, rot.y, rot.z, rot.w);
            });
        }

        function updateJointMotion(deltaTime) {
            const speed = CONFIG.arm.jointSpeed * 180 / Math.PI * deltaTime; // degrees per frame
            let moving = false;

            for (let i = 0; i < 6; i++) {
                const diff = jointTargets[i] - jointAngles[i];
                if (Math.abs(diff) > 0.5) {
                    moving = true;
                    const step = Math.sign(diff) * Math.min(Math.abs(diff), speed);
                    jointAngles[i] += step;
                }
            }

            return moving;
        }

        // Animation loop
        let lastTime = performance.now();
        let lastSaveTime = 0;
        const SAVE_INTERVAL = 2000; // Save state every 2 seconds

        function animate() {
            requestAnimationFrame(animate);

            const now = performance.now();
            const deltaTime = (now - lastTime) / 1000;
            lastTime = now;

            // Update joint positions toward targets
            updateJointMotion(deltaTime);

            // Update arm kinematics BEFORE physics step
            const endEffectorPos = updateArmKinematics();

            // Apply magnetic force BEFORE physics step (modifies kinematic/dynamic bodies)
            updateMagneticForce();

            // Step physics AFTER all kinematic updates
            world.step(eventQueue);

            // Sync physics bodies to visuals AFTER physics step
            syncPhysicsToVisuals();

            // Update UI
            document.getElementById('end-effector-pos').textContent =
                `(${endEffectorPos.x.toFixed(2)}, ${endEffectorPos.y.toFixed(2)}, ${endEffectorPos.z.toFixed(2)})`;

            updateObjectList();

            // Report motion status to server for task coordination
            reportMotionStatus();

            // Periodically save object positions
            if (now - lastSaveTime > SAVE_INTERVAL) {
                lastSaveTime = now;
                saveObjectPositions();
            }

            controls.update();
            renderer.render(scene, camera);
        }

        function updateObjectList() {
            const listEl = document.getElementById('object-list');
            listEl.innerHTML = '';
            objectBodies.forEach(({ body, mesh, config }, id) => {
                const pos = body.translation();
                const attached = mesh.userData.attached || false;
                const div = document.createElement('div');
                div.className = 'object-item' + (attached ? ' attached' : '');
                div.innerHTML = `
                    <span>${id}</span>
                    <span>${attached ? 'ðŸ§²' : `(${pos.x.toFixed(2)}, ${pos.z.toFixed(2)})`}</span>
                `;
                listEl.appendChild(div);
            });
        }

        function createJointControls() {
            const container = document.getElementById('joint-controls');
            CONFIG.arm.segments.forEach((seg, i) => {
                const div = document.createElement('div');
                div.className = 'joint-control';
                div.innerHTML = `
                    <label>
                        <span>Joint ${i + 1} (${seg.axis.toUpperCase()})</span>
                        <span class="joint-value" id="joint-${i}-value">${jointAngles[i]}Â°</span>
                    </label>
                    <input type="range" id="joint-${i}"
                           min="${seg.range[0]}" max="${seg.range[1]}"
                           value="${jointAngles[i]}" step="1">
                `;
                container.appendChild(div);

                const slider = div.querySelector('input');
                slider.addEventListener('input', (e) => {
                    markUserControl();
                    const angle = parseFloat(e.target.value);
                    jointTargets[i] = angle;
                    sendCommand('move_joint', { joint: i, angle });
                });
            });
        }

        // Server communication
        async function sendCommand(tool, args) {
            try {
                await fetch(`${API_BASE}/api/tools/${tool}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(args)
                });
            } catch (e) {
                console.error('Command failed:', e);
            }
        }

        // Polling-based server sync (works with Vercel serverless)
        let pollingActive = false;
        let userIsControlling = false;
        let userControlTimeout = null;

        // Track when user is actively moving sliders to avoid server overwrite
        function markUserControl() {
            userIsControlling = true;
            clearTimeout(userControlTimeout);
            userControlTimeout = setTimeout(() => { userIsControlling = false; }, 2000);
        }

        function startPolling() {
            if (pollingActive) return;
            pollingActive = true;

            document.getElementById('mcp-connected').textContent = 'Connected';
            document.getElementById('mcp-connected').style.color = '#2ecc71';

            setInterval(async () => {
                try {
                    const res = await fetch(`${API_BASE}/api/state`);
                    if (!res.ok) return;
                    const state = await res.json();

                    // Check for pending MCP command from server
                    if (state.pendingCommand && !processingCommand) {
                        processCommand(state.pendingCommand);
                        return; // Skip normal state sync while processing
                    }

                    // Skip state sync while user is actively controlling
                    if (userIsControlling) return;
                    // Skip state sync while executing a command
                    if (processingCommand) return;

                    // Apply joint target changes from server (MCP commands)
                    if (state.jointTargets) {
                        let changed = false;
                        for (let i = 0; i < 6; i++) {
                            if (Math.abs(state.jointTargets[i] - jointTargets[i]) > 0.5) {
                                changed = true;
                                break;
                            }
                        }
                        if (changed) {
                            state.jointTargets.forEach((angle, i) => {
                                jointTargets[i] = angle;
                                updateSliderUI(i, angle);
                            });
                        }
                    }

                    // Apply magnet state changes from server
                    if (state.magnetOn !== undefined && state.magnetOn !== magnetOn) {
                        magnetOn = state.magnetOn;
                        updateMagnetUI();
                    }
                } catch (e) {
                    // Polling error - ignore, will retry next interval
                }
            }, 500);
        }

        function updateSliderUI(joint, angle) {
            const slider = document.getElementById(`joint-${joint}`);
            const valueEl = document.getElementById(`joint-${joint}-value`);
            if (slider) slider.value = angle;
            if (valueEl) valueEl.textContent = `${Math.round(angle)}Â°`;
        }

        function updateMagnetUI() {
            const indicator = document.getElementById('magnet-indicator');
            const btn = document.getElementById('magnet-btn');
            const statusEl = document.getElementById('magnet-status');

            if (magnetOn) {
                indicator.classList.add('active');
                btn.classList.add('active');
                btn.textContent = 'ðŸ§² Magnet ON';
                statusEl.textContent = 'ON';
                statusEl.style.color = '#e94560';
            } else {
                indicator.classList.remove('active');
                btn.classList.remove('active');
                btn.textContent = 'ðŸ§² Magnet OFF';
                statusEl.textContent = 'OFF';
                statusEl.style.color = '#888';
            }
        }

        // Global functions for UI
        window.toggleMagnet = function() {
            markUserControl();
            magnetOn = !magnetOn;
            updateMagnetUI();
            sendCommand('set_magnet', { enabled: magnetOn });
        };

        window.resetArm = function() {
            markUserControl();
            jointTargets = [0, 0, 0, 0, 0, 0];
            magnetOn = false;
            updateMagnetUI();
            sendCommand('reset_arm', {});
        };

        window.resetObjects = function() {
            CONFIG.objects.forEach(objConfig => {
                const data = objectBodies.get(objConfig.id);
                if (data) {
                    // Use DEFAULT positions, not persisted positions
                    const defaultPos = DEFAULT_OBJECT_POSITIONS[objConfig.id] || objConfig.position;
                    data.body.setTranslation({ x: defaultPos[0], y: defaultPos[1], z: defaultPos[2] }, true);
                    data.body.setRotation({ x: 0, y: 0, z: 0, w: 1 }, true);
                    data.body.setLinvel({ x: 0, y: 0, z: 0 }, true);
                    data.body.setAngvel({ x: 0, y: 0, z: 0 }, true);
                    data.mesh.userData.attached = false;
                }
            });
        };

        // Start
        init().catch(console.error);
    </script>
</body>
</html>
